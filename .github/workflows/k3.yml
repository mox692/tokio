name: Kernel CIs

on:
  push:
    branches:
      - master
  workflow_call:
    inputs:
      kernel_version:
        description: 'Version of the Linux kernel to build'
        required: true
        type: string


jobs:
  build:
    runs-on: ubuntu-latest
    env:
      KERNEL_VERSION: ${{ inputs.kernel_version }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential libncurses-dev bison flex libssl-dev libelf-dev dwarves \
            qemu-system-x86 busybox-static cpio xz-utils curl

      # - name: Get latest kernel version
      #   id: get-kernel
      #   run: |
      #     KERNEL_VERSION=$(curl -s https://www.kernel.org/releases.json | jq -r '.latest_stable.version')
      #     echo "KERNEL_VERSION=$KERNEL_VERSION" >> $GITHUB_ENV

      - name: Cache built kernel
        id: kernel-cache
        uses: actions/cache@v4
        with:
          path: linux-${{ env.KERNEL_VERSION }}
          key: ${{ env.KERNEL_VERSION }}

      - name: Download Linux kernel source
        if: steps.kernel-cache.outputs.cache-hit != 'true'
        run: |
          MAJOR=$(echo "${{ env.KERNEL_VERSION }}" | cut -d. -f1)
          wget https://cdn.kernel.org/pub/linux/kernel/v${MAJOR}.x/linux-${{ env.KERNEL_VERSION }}.tar.xz
          tar -xf linux-${{ env.KERNEL_VERSION }}.tar.xz

      - name: Build Linux kernel
        if: steps.kernel-cache.outputs.cache-hit != 'true'
        run: |
          echo "Building Linux kernel $KERNEL_VERSION..."
          cd linux-${{ env.KERNEL_VERSION }}
          make defconfig
          make -j$(nproc)
          echo "Kernel build complete."

      - name: Install cargo-hack
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-hack

      - name: Build Rust project
        run: |
          rustup target add x86_64-unknown-linux-musl
          RUSTFLAGS="--cfg tokio_uring" cargo hack test -p tokio --features full --target x86_64-unknown-linux-musl --test 'fs*'

      - name: Create initramfs directory structure
        run: |
          echo "Creating initramfs directories..."
          mkdir -p initramfs/{bin,sbin,proc,sys}
          mkdir -m 1777 initramfs/tmp
          mkdir -p initramfs/bin/tests

      - name: Copy Rust test binaries into initramfs
        run: |
          echo "Copying Rust test binaries..."
          ls target/x86_64-unknown-linux-musl/debug/deps/ \
            | grep -Ev '\.(o|d)$' \
            | grep '^fs_.*' \
            | sed 's|^|target/x86_64-unknown-linux-musl/debug/deps/|' \
            | xargs -I{} cp {} initramfs/bin/tests

      - name: Add BusyBox and create symlinks
        run: |
          echo "Adding BusyBox and symlinks..."
          cp /usr/bin/busybox initramfs/bin/busybox
          ln -s busybox initramfs/bin/sh
          ln -s busybox initramfs/bin/mount
          ln -s ../bin/busybox initramfs/sbin/poweroff

      - name: Generate init script
        run: |
          echo "Generating init script..."
          cat > initramfs/init << 'EOL'
          #!/bin/sh
          set -e
          mount -t proc proc /proc
          mount -t sysfs sysfs /sys
          mkdir -p /tmp
          mount -t tmpfs -o mode=1777 tmpfs /tmp

          echo "Launching Rust application..."
          for f in /bin/tests/*; do RUST_BACKTRACE=1 "$f"; done

          echo "Application exited, powering off..."
          /sbin/poweroff -f
          EOL
          chmod +x initramfs/init

      - name: Pack initramfs into CPIO archive
        run: |
          echo "Packing initramfs..."
          (cd initramfs && find . -print0 | cpio --null -ov --format=newc | gzip -9 > ../initramfs.cpio.gz)
          echo "Initramfs prepared."

      - name: Run QEMU with kernel and initramfs
        run: |
          echo "Booting QEMU with Linux $KERNEL_VERSION..."
          qemu-system-x86_64 -kernel linux-${{ env.KERNEL_VERSION }}/arch/x86/boot/bzImage \
                             -initrd initramfs.cpio.gz \
                             -append "console=ttyS0 rootfstype=ramfs" -nographic -no-reboot -m 1024
                      
          # if grep -q "panicked at " qemu-output.log; then
          #   echo "error: unexpected error in QEMU run"
          #   exit 1
          # fi
          # echo "QEMU run completed."

          if [ $? -ne 0 ]; then
            echo "tests failed (QEMU exited abnormally)"
            exit 1
          else
            echo "all tests passed"
          fi
